description = "Execute type-driven development: CREATE Idris 2 types from plan, VERIFY through type checking, then IMPLEMENT target code"

prompt = '''You are executing TYPE-DRIVEN DEVELOPMENT with Idris 2. Your mission: CREATE the type specifications designed in the plan phase, VERIFY them through type checking, then IMPLEMENT target language code that honors the type contracts.

## Philosophy: Types Guide Implementation

This is the EXECUTION phase. The plan phase designed dependent types, function signatures, and proof obligations. Now you:
1. CREATE Idris 2 type definitions and signatures
2. VERIFY through type checking and totality
3. IMPLEMENT target code that mirrors type structure
4. VALIDATE through property tests derived from types

## Constitutional Rules (Non-Negotiable)

1. **CREATE Types First**: All type definitions before implementation
2. **Types Never Lie**: If it doesn't type-check, fix implementation (not types)
3. **Holes Before Bodies**: Use ?holes, let type checker guide implementation
4. **Totality Enforced**: Mark functions total, prove termination
5. **Pattern Match Exhaustive**: All cases covered

## Execution Workflow

### Phase 1: CREATE Type Artifacts

**Objective**: Generate Idris 2 type specification files from plan design

```bash
# Create type specification directory
mkdir -p .outline/proofs

# Verify Idris 2 installation
idris2 --version  # Expect v0.8.0+

# Initialize package
cd .outline/proofs
pack new myproject
```

**Create Type Definitions (from plan):**
```idris
-- .outline/proofs/src/Types.idr
module Types

-- Result type for error handling (from plan)
public export
data Result : Type -> Type -> Type where
  Ok  : a -> Result a e
  Err : e -> Result a e

-- Non-empty proof (from plan)
public export
data NonEmpty : List a -> Type where
  IsNonEmpty : NonEmpty (x :: xs)

-- Positive natural (from plan)
public export
data Positive : Nat -> Type where
  MkPositive : Positive (S n)

-- Bounded index (from plan)
-- Fin n can only hold values 0..n-1
```

**Create Function Signatures (from plan):**
```idris
-- .outline/proofs/src/Operations.idr
module Operations

import Types

-- Safe head: requires non-empty proof (from plan)
public export
head : (xs : List a) -> {auto prf : NonEmpty xs} -> a

-- Safe division: requires non-zero proof (from plan)
public export
div : (x : Nat) -> (y : Nat) -> {auto prf : Positive y} -> Nat

-- Index: bounded by vector length (from plan)
public export
index : Fin n -> Vect n a -> a
```

**Create State Machine Types (from plan):**
```idris
-- .outline/proofs/src/StateMachine.idr
module StateMachine

-- State enum (from plan)
public export
data State = Open | Closed | Locked

-- State-indexed type (from plan)
public export
data Door : State -> Type where
  MkDoor : Door Closed

-- Type-safe transitions (from plan)
public export
openDoor : Door Closed -> Door Open

public export
closeDoor : Door Open -> Door Closed

public export
lockDoor : Door Closed -> Door Locked

-- Invalid transitions are TYPE ERRORS
-- openLocked : Door Locked -> Door Open  -- Won't compile
```

### Phase 2: VERIFY Through Type Checking

**Objective**: Verify types compile and satisfy constraints

**Type Check Commands:**
```bash
# Check types compile
idris2 --check .outline/proofs/src/Types.idr

# Check all modules
idris2 --check .outline/proofs/src/*.idr

# Verify totality (all functions terminate)
idris2 --total --check .outline/proofs/src/Operations.idr

# Check pattern coverage
idris2 --check .outline/proofs/src/*.idr 2>&1 | rg "not covering"
# Expected: no output (all patterns covered)
```

**Interactive Development (REPL):**
```bash
# Start REPL
pack repl myproject

# Query types
:t head
:t div
:t openDoor

# Case split for implementation
:cs 1 head_rhs xs

# Proof search
:ps 1 div_rhs
```

### Phase 3: Implement in Idris 2

**Objective**: Fill in function bodies using type-driven development

**Hole-Driven Implementation:**
```idris
-- Start with holes
head : (xs : List a) -> {auto prf : NonEmpty xs} -> a
head xs = ?head_rhs

-- Query hole type
-- :t head_rhs shows what's needed

-- Case split
head (x :: xs) = ?head_rhs_1

-- Fill in (type checker validates)
head (x :: xs) = x
```

**Example Implementations:**
```idris
-- Safe head (no case for empty - type prevents it)
head : (xs : List a) -> {auto prf : NonEmpty xs} -> a
head (x :: xs) = x

-- Safe division
div : (x : Nat) -> (y : Nat) -> {auto prf : Positive y} -> Nat
div x (S k) = x `div` (S k)

-- State machine transitions
openDoor : Door Closed -> Door Open
openDoor MkDoor = MkDoor

closeDoor : Door Open -> Door Closed
closeDoor MkDoor = MkDoor
```

### Phase 4: Implement Target Language Code

**Objective**: Create target implementation mirroring Idris types

**Type Correspondence Table:**
| Idris 2 | TypeScript | Rust | Python |
|---------|------------|------|--------|
| `Maybe a` | `T \| null` | `Option<T>` | `Optional[T]` |
| `Either a b` | `A \| B` | `Result<T,E>` | `Union[A,B]` |
| `Vect n a` | `T[]` + assert | `[T; N]` | `list` + assert |
| `Fin n` | `number` + check | bounded int | `int` + check |
| `Positive n` | `number` + check | NonZeroU32 | `int` + assert |

**TypeScript Implementation:**
```typescript
// Types from Idris specification
type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };

// Head: runtime check for non-empty (Idris enforces at compile time)
function head<T>(xs: T[]): T {
  if (xs.length === 0) throw new Error('NonEmpty violation');
  return xs[0];
}

// Div: runtime check for positive (Idris enforces at compile time)
function div(x: number, y: number): number {
  if (y <= 0) throw new Error('Positive violation');
  return Math.floor(x / y);
}

// State machine: use discriminated unions
type DoorState = 'open' | 'closed' | 'locked';
type Door<S extends DoorState> = { state: S };

function openDoor(door: Door<'closed'>): Door<'open'> {
  return { state: 'open' };
}
// openDoor({ state: 'locked' })  // TYPE ERROR
```

**Property Tests from Types:**
```typescript
import fc from 'fast-check';

// Property: head returns first element (from Idris type)
fc.assert(
  fc.property(fc.array(fc.integer(), { minLength: 1 }), (xs) => {
    return head(xs) === xs[0];
  })
);

// Property: div with positive divisor doesn't throw (from Idris type)
fc.assert(
  fc.property(fc.integer(), fc.integer({ min: 1 }), (x, y) => {
    const result = div(x, y);
    return typeof result === 'number';
  })
);
```

## Validation Gates

| Gate | Command | Pass Criteria | Blocking |
|------|---------|---------------|----------|
| Types Compile | `idris2 --check` | No errors | Yes |
| Totality | `idris2 --total --check` | All total | Yes |
| Coverage | Check "not covering" | None | Yes |
| Holes | `rg "\\?"` | Zero | Yes |
| Target Build | `tsc` / `cargo build` | Success | Yes |
| Property Tests | Test suite | All pass | Yes |

## Required Output

1. **Idris 2 Types** - Complete in `.outline/proofs/`
2. **Type Check Output** - Clean compilation
3. **Target Implementation** - With type correspondence
4. **Property Tests** - From type signatures
5. **Type-Code Mapping** - Idris type -> Target implementation

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Types verified, implementation complete |
| 11 | Idris 2 not installed |
| 12 | Type check failed |
| 13 | Totality check failed |
| 14 | Holes remaining |
| 15 | Target implementation failed |

Execute CREATE -> VERIFY -> IMPLEMENT cycle until types pass and target implementation complete.
'''
