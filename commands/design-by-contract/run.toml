description = "Execute design-by-contract: CREATE contract annotations from plan, VERIFY enforcement, then TEST violations"

prompt = '''You are executing DESIGN-BY-CONTRACT development. Your mission: CREATE the contract annotations designed in the plan phase, VERIFY they are enforced at runtime, and TEST that violations are properly caught.

## Philosophy: Contracts Are Executable Specifications

This is the EXECUTION phase. The plan phase designed preconditions, postconditions, and invariants. Now you:
1. CREATE contract annotations in target language
2. VERIFY contracts are enforced (static analysis + runtime)
3. TEST that contract violations are properly caught
4. DOCUMENT contract-code correspondence

## Constitutional Rules (Non-Negotiable)

1. **CREATE All Contracts**: Add all planned annotations before testing
2. **Every Public API Has Preconditions**: No exceptions
3. **Side Effects Have Postconditions**: State changes documented
4. **Stateful Classes Have Invariants**: Class constraints enforced
5. **Test Violations**: Verify contracts catch invalid inputs

## Execution Workflow

### Phase 1: CREATE Contract Artifacts

**Objective**: Add contract annotations from plan design

**Install Contract Libraries:**
```bash
# Python
pip install deal

# Rust
cargo add contracts

# TypeScript
npm install zod

# Kotlin - built-in (require/check)
```

**Create Python Contracts (deal):**
```python
# src/account.py
import deal
from dataclasses import dataclass
from enum import Enum

class AccountStatus(Enum):
    ACTIVE = "active"
    FROZEN = "frozen"
    CLOSED = "closed"

# Invariant: balance always >= 0 (from plan INV-1)
@deal.inv(lambda self: self.balance >= 0, message="INV: balance >= 0")
@dataclass
class Account:
    id: str
    balance: int
    status: AccountStatus = AccountStatus.ACTIVE

    # Preconditions from plan PRE-1, PRE-2, PRE-3
    @deal.pre(lambda self, amount: amount > 0, message="PRE: amount > 0")
    @deal.pre(lambda self, amount: amount <= self.balance, message="PRE: amount <= balance")
    @deal.pre(lambda self: self.status == AccountStatus.ACTIVE, message="PRE: status == ACTIVE")
    # Postconditions from plan POST-1, POST-2
    @deal.post(lambda result: result > 0, message="POST: result > 0")
    @deal.ensure(
        lambda self, amount, result: self.balance == deal.old(self.balance) - amount,
        message="POST: balance == old(balance) - amount"
    )
    def withdraw(self, amount: int) -> int:
        self.balance -= amount
        return amount
```

**Create Rust Contracts (contracts crate):**
```rust
// src/account.rs
use contracts::*;

#[derive(Debug)]
pub struct Account {
    id: String,
    balance: u64,
    status: AccountStatus,
}

#[contract_trait]
impl Account {
    // Invariant from plan INV-1
    #[debug_invariant(self.balance <= u64::MAX)]
    pub fn new(id: String, initial: u64) -> Self {
        Self { id, balance: initial, status: AccountStatus::Active }
    }

    // Preconditions from plan PRE-1, PRE-2, PRE-3
    #[requires(amount > 0, "PRE: amount > 0")]
    #[requires(amount as u64 <= self.balance, "PRE: amount <= balance")]
    #[requires(self.status == AccountStatus::Active, "PRE: status == Active")]
    // Postconditions from plan POST-1, POST-2
    #[ensures(ret == amount as u64, "POST: result == amount")]
    #[ensures(self.balance == old(self.balance) - amount as u64, "POST: balance correct")]
    pub fn withdraw(&mut self, amount: u32) -> u64 {
        let amount = amount as u64;
        self.balance -= amount;
        amount
    }
}
```

**Create TypeScript Contracts (Zod + assertions):**
```typescript
// src/account.ts
import { z } from 'zod';

// Schema contracts (from plan)
const PositiveAmount = z.number().positive({ message: 'PRE: amount > 0' });
const NonNegativeBalance = z.number().nonnegative({ message: 'INV: balance >= 0' });

function requires(condition: boolean, message: string): asserts condition {
  if (!condition) throw new PreconditionError(message);
}

function ensures(condition: boolean, message: string): asserts condition {
  if (!condition) throw new PostconditionError(message);
}

class Account {
  private balance: number;
  private status: AccountStatus;

  withdraw(amount: number): number {
    // Preconditions from plan
    PositiveAmount.parse(amount);
    requires(amount <= this.balance, 'PRE: amount <= balance');
    requires(this.status === 'active', 'PRE: status == active');

    const oldBalance = this.balance;

    // Implementation
    this.balance -= amount;

    // Postconditions from plan
    ensures(this.balance === oldBalance - amount, 'POST: balance correct');
    NonNegativeBalance.parse(this.balance);  // Invariant

    return amount;
  }
}
```

**Create Kotlin Contracts (built-in):**
```kotlin
// src/Account.kt
class Account(val id: String, initialBalance: Long) {
    var balance: Long = initialBalance
        private set

    var status: AccountStatus = AccountStatus.ACTIVE
        private set

    init {
        // Invariant from plan INV-1
        check(balance >= 0) { "INV: balance >= 0" }
    }

    fun withdraw(amount: Long): Long {
        // Preconditions from plan PRE-1, PRE-2, PRE-3
        require(amount > 0) { "PRE: amount > 0" }
        require(amount <= balance) { "PRE: amount <= balance" }
        require(status == AccountStatus.ACTIVE) { "PRE: status == ACTIVE" }

        val oldBalance = balance

        // Implementation
        balance -= amount

        // Postconditions from plan POST-1, POST-2
        check(balance == oldBalance - amount) { "POST: balance correct" }
        check(balance >= 0) { "INV: balance >= 0" }

        return amount
    }
}
```

### Phase 2: VERIFY Contract Enforcement

**Objective**: Verify contracts are checked at runtime

**Static Analysis:**
```bash
# Python
deal lint src/

# Rust (contracts checked at compile time in debug)
cargo build

# TypeScript
npx tsc --noEmit
```

**Runtime Verification:**
```bash
# Python - contracts enabled by default
python -c "from src.account import Account; Account('1', 100).withdraw(-50)"
# Expected: deal.PreContractError

# Rust - contracts enabled in debug builds
cargo test

# TypeScript
npm test
```

### Phase 3: TEST Contract Violations

**Objective**: Write tests that verify contracts catch violations

**Create Violation Tests:**
```python
# tests/test_contracts.py
import pytest
from deal import PreContractError, PostContractError, InvContractError

class TestPreconditionViolations:
    """Tests from plan - verify PRE contracts"""

    def test_negative_amount_violates_pre(self):
        """PRE-1: amount > 0"""
        account = Account(id="1", balance=100)
        with pytest.raises(PreContractError, match="amount > 0"):
            account.withdraw(-50)

    def test_insufficient_funds_violates_pre(self):
        """PRE-2: amount <= balance"""
        account = Account(id="1", balance=100)
        with pytest.raises(PreContractError, match="amount <= balance"):
            account.withdraw(150)

    def test_frozen_account_violates_pre(self):
        """PRE-3: status == ACTIVE"""
        account = Account(id="1", balance=100, status=AccountStatus.FROZEN)
        with pytest.raises(PreContractError, match="status"):
            account.withdraw(50)


class TestPostconditionGuarantees:
    """Tests from plan - verify POST contracts"""

    def test_withdraw_returns_exact_amount(self):
        """POST-1: result == amount"""
        account = Account(id="1", balance=100)
        result = account.withdraw(30)
        assert result == 30

    def test_balance_updated_correctly(self):
        """POST-2: balance == old(balance) - amount"""
        account = Account(id="1", balance=100)
        account.withdraw(30)
        assert account.balance == 70


class TestInvariantMaintenance:
    """Tests from plan - verify INV contracts"""

    def test_balance_never_negative(self):
        """INV-1: balance >= 0"""
        account = Account(id="1", balance=100)
        account.withdraw(50)
        account.deposit(25)
        account.withdraw(75)
        assert account.balance >= 0
```

### Phase 4: Document Contract Correspondence

**Objective**: Create mapping between plan and implementation

**Correspondence Table:**
```markdown
## Contract-Code Correspondence

| Plan Contract | Code Location | Enforcement |
|---------------|---------------|-------------|
| PRE-1: amount > 0 | account.py:25 | @deal.pre |
| PRE-2: amount <= balance | account.py:26 | @deal.pre |
| PRE-3: status == ACTIVE | account.py:27 | @deal.pre |
| POST-1: result > 0 | account.py:29 | @deal.post |
| POST-2: balance correct | account.py:30 | @deal.ensure |
| INV-1: balance >= 0 | account.py:15 | @deal.inv |
```

## Validation Gates

| Gate | Command | Pass Criteria | Blocking |
|------|---------|---------------|----------|
| Static Analysis | `deal lint` | No warnings | Yes |
| Type Check | `pyright` / `tsc` | No errors | Yes |
| Violation Tests | `pytest test_contracts.py` | All pass | Yes |
| Guarantee Tests | `pytest test_contracts.py` | All pass | Yes |
| Full Test Suite | `pytest` | All pass | Yes |

## Required Output

1. **Annotated Code** - All contracts from plan added
2. **Static Analysis Output** - Clean `deal lint` / equivalent
3. **Violation Tests** - Tests for each precondition
4. **Guarantee Tests** - Tests for each postcondition
5. **Correspondence Table** - Plan contract -> code location

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | All contracts verified and tested |
| 11 | Contract library not installed |
| 12 | Static analysis failed |
| 13 | Contract tests failed |
| 14 | Missing contract coverage |

Execute CREATE -> VERIFY -> TEST cycle until all contracts are properly enforced and tested.
'''
