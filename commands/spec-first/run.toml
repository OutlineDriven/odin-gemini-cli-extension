description = "Execute spec-first development: CREATE Quint specs from plan, VERIFY with model checking, then IMPLEMENT"

prompt = '''You are executing SPEC-FIRST DEVELOPMENT. Your mission: CREATE the Quint specifications designed in the plan phase, VERIFY them through simulation and model checking, then IMPLEMENT target code that matches the verified spec.

## Philosophy: Create Specs, Verify, Then Implement

This is the EXECUTION phase. The plan phase designed state models, operations, and invariants. Now you:
1. CREATE the Quint specification files
2. VERIFY through simulation and model checking
3. IMPLEMENT target code matching the spec
4. VALIDATE correspondence through property tests

## Constitutional Rules (Non-Negotiable)

1. **CREATE First**: Generate all Quint artifacts from plan design before verification
2. **Model Check Before Implement**: No implementation until specs pass verification
3. **Counterexamples Are Gifts**: They reveal design flaws before code exists
4. **Spec-Code Correspondence**: Each Quint element maps to implementation code
5. **Iterative Refinement**: Fix spec issues, don't skip verification

## Execution Workflow

### Phase 1: CREATE Validation Artifacts

**Objective**: Generate Quint specification files from plan design

```bash
# Create specification directory
mkdir -p .outline/specs

# Verify Quint installation
quint --version  # Expect v0.21+
```

**Create Type Definitions (from plan):**
```quint
// .outline/specs/types.qnt
// Types designed in plan phase

type EntityId = str
type Amount = int
type Status = Active | Inactive | Pending

type Entity = {
  id: EntityId,
  value: Amount,
  status: Status
}
```

**Create State Model (from plan):**
```quint
// .outline/specs/state.qnt
module state {
  import types.*

  var entities: EntityId -> Entity

  action init = all {
    entities' = Map()
  }
}
```

**Create Operations (from plan):**
```quint
// .outline/specs/operations.qnt
module operations {
  import state.*

  // [Operations designed in plan phase]
  action operation_name(params): bool = all {
    // Preconditions
    [precondition_1],
    [precondition_2],
    // State update
    entities' = entities.set(...)
  }
}
```

**Create Invariants (from plan):**
```quint
// .outline/specs/invariants.qnt
module invariants {
  import state.*

  // [Invariants designed in plan phase]
  val invariant_name: bool =
    entities.keys().forall(id => [property])

  val allInvariants = invariant_name and [other_invariants]
}
```

**Create Main Module:**
```quint
// .outline/specs/main.qnt
module main {
  import types.*
  import state.*
  import operations.*
  import invariants.*

  action step = any {
    nondet id = entities.keys().oneOf()
    nondet amount = 1.to(100).oneOf()
    any {
      operation_1(id, amount),
      operation_2(id, amount),
      // ...
    }
  }
}
```

### Phase 2: EXECUTE Verification

**Objective**: Verify specifications through simulation and model checking

**Step 1: Type Check**
```bash
quint typecheck .outline/specs/main.qnt
# Expected: [ok] No errors found
```

**Step 2: REPL Exploration**
```bash
# Start interactive REPL
quint -r .outline/specs/main.qnt::main

# In REPL:
>>> init
>>> operation_1("id1", 100)
>>> entities
>>> allInvariants  # Should be true
```

**Step 3: Random Simulation**
```bash
# Run simulation with invariant checking
quint run --main=main --max-steps=100 --invariant=allInvariants .outline/specs/main.qnt

# Run multiple samples
quint run --main=main --max-steps=50 --max-samples=10 .outline/specs/main.qnt
```

**Step 4: Model Checking (Apalache)**
```bash
# Verify invariants with bounded model checking
quint verify --main=main --invariant=allInvariants --max-steps=10 .outline/specs/main.qnt

# Expected: [ok] No violation found
```

### Phase 3: REMEDIATE (Fix Spec Issues)

**Objective**: Address any verification failures

**Remediation Loop:**
```
WHILE verification fails:
  1. Analyze counterexample trace
  2. Determine cause:
     - Invariant too strong? -> Weaken invariant
     - Missing precondition? -> Add precondition
     - Incorrect state update? -> Fix operation
  3. Update specification
  4. Re-verify
```

**Counterexample Analysis:**
```bash
# Output counterexample to file
quint verify --main=main --invariant=allInvariants --out-itf=counterexample.itf.json .outline/specs/main.qnt

# View trace
cat counterexample.itf.json | jq '.states'
```

### Phase 4: Implement Target Language Code

**Objective**: Create implementation matching verified specification

**Spec-to-Code Translation:**

| Quint | TypeScript | Python | Rust |
|-------|------------|--------|------|
| `type T = {...}` | `interface T` | `@dataclass T` | `struct T` |
| `var x: T` | `let x: T` | `self.x: T` | `let mut x: T` |
| `action f(...): bool` | `function f(): Result` | `def f() -> Result` | `fn f() -> Result` |
| `all { cond, ... }` | `if (!cond) return Err` | `if not cond: raise` | `if !cond { return Err }` |

**Implementation with Spec Correspondence:**
```typescript
// account.ts: Implementation from Quint spec

/**
 * Spec Correspondence:
 * - Quint module: operations
 * - Quint action: withdraw
 * - Invariants: balanceNonNegative
 */
function withdraw(account: Account, amount: number): Result<number> {
  // Preconditions (from Quint action)
  if (amount <= 0) return { ok: false, error: 'Amount must be positive' };
  if (amount > account.balance) return { ok: false, error: 'Insufficient funds' };

  // State update (from Quint accounts' = ...)
  account.balance -= amount;

  // Postcondition (invariant check)
  assert(account.balance >= 0, 'Invariant violated');

  return { ok: true, value: amount };
}
```

**Property Tests from Spec:**
```typescript
import fc from 'fast-check';

// Property: Invariant always holds (from Quint val balanceNonNegative)
fc.assert(
  fc.property(fc.integer({ min: 0, max: 1000 }), fc.integer({ min: 1, max: 100 }),
    (initial, amount) => {
      const account = createAccount(initial);
      const result = withdraw(account, amount);
      // Invariant must hold regardless of success/failure
      return account.balance >= 0;
    }
  )
);
```

## Validation Gates

| Gate | Command | Pass Criteria | Blocking |
|------|---------|---------------|----------|
| Type Check | `quint typecheck` | No errors | Yes |
| Simulation | `quint run --invariant=inv` | No violations | Yes |
| Model Check | `quint verify --invariant=inv` | No counterexamples | Yes |
| Target Build | `npm build` / `cargo build` | Success | Yes |
| Property Tests | `npm test` / `cargo test` | All pass | Yes |

## Required Output

1. **Quint Specification** - Complete in `.outline/specs/`
2. **Verification Output** - `quint verify` success
3. **Implementation** - With spec correspondence documented
4. **Property Tests** - From spec properties
5. **Spec-Code Mapping** - Which Quint element maps to which code

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Spec verified, implementation complete |
| 11 | Quint not installed |
| 12 | Type check failed |
| 13 | Simulation found violation |
| 14 | Model check found counterexample |
| 15 | Implementation failed |

Execute CREATE -> VERIFY -> REMEDIATE cycle until spec passes and implementation complete.
'''
